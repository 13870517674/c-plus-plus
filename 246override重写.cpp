/* 在派生类中，重写 (override) 继承自基类成员函数的实现 (implementation) 时，要满足如下条件：
  一虚：基类中，成员函数声明为虚拟的 (virtual)
  二容：基类和派生类中，成员函数的返回类型和异常规格 (exception specification) 必须兼容
  四同：基类和派生类中，成员函数名、形参类型、常量属性 (constness) 和 引用限定符 (reference qualifier) 必须完全相同
  如此多的限制条件，导致了虚函数重写如上述代码，极容易因为一个不小心而出错
  C++11 中的 override 关键字，可以显式的在派生类中声明，哪些成员函数需要被重写，如果没被重写，则编译器会报错。 */

/*在派生类中，重写 (override) 继承自基类成员函数的实现 (implementation) 时，要满足如下条件：
  一虚：基类中，成员函数声明为虚拟的 (virtual)
  二容：基类和派生类中，成员函数的返回类型和异常规格 (exception specification) 必须兼容
  四同：基类和派生类中，成员函数名、形参类型、常量属性 (constness) 和 引用限定符 (reference qualifier) 必须完全相同
  如此多的限制条件，导致了虚函数重写如上述代码，极容易因为一个不小心而出错
  C++11 中的 override 关键字，可以显式的在派生类中声明，哪些成员函数需要被重写，如果没被重写，则编译器会报错。 */

//简单的说就是在派生类的重写基类的函数的成员函数上加上override