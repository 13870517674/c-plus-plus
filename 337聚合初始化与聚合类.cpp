#include<iostream>
/*
	聚合体 是下列类型之一：

	数组类型
	符合以下条件的类类型（通常是 struct 或 union）
	没有私有或受保护的直接 (C++17 起)非静态数据成员
	没有用户声明的构造函数(C++11 前)
	没有用户提供、继承或 explicit 的构造函数(C++11 起)(C++20 前)
	没有用户声明或继承的构造函数(C++20 起)
	没有虚、私有或受保护 (C++17 起)的基类
	没有虚成员函数
	没有默认成员初始化器(C++11 起)(C++14 前)

	聚合体的 元素 有：

	对于数组，按下标顺序包含所有数组元素，或者，
	对于类，按声明顺序包含所有不是匿名位域的非静态数据成员。
	(C++17 前)
	对于类，按声明顺序包含所有直接基类，然后按声明顺序包含所有不是匿名位域或匿名联合体成员的非静态数据成员。
	(C++17 起)

*/

struct C
{
	union
	{
		int a;
		const char* p;
	};

	int x;
} c = { .a = 1, .x = 3 }; // 以 1 初始化 c.a 并且以 3 初始化 c.x


union u { int a; const char* b; };
u a = { 1 };                   // OK：显式初始化成员 a
	//u b = { 0, "asdf" };           // 错误：显式初始化两个成员
	//u c = { "asdf" };              // 错误：不能以 "asdf" 初始化 int

	// C++20 指派初始化器列表
u d = { .b = "asdf" };         // OK：可以显示初始化非开头元素
//u e = { .a = 1, .b = "asdf" }; // 错误：显式初始化两个成员


struct A { int x; int y; int z; };
//A a{ .y = 2, .x = 1 }; // 错误：指派符的顺序不匹配声明顺序
A b{ .x = 1, .z = 2 }; // OK：b.y 被初始化为 0


// 聚合体
struct base1 { int b1, b2 = 42; };

// 非聚合体
struct base2
{
	base2() : b3(42) {}

	int b3;
};

// C++17 里是聚合体
struct derived : base1, base2 { int d; };

derived d1{ {1, 2}, {}, 4 }; // d1.b1 = 1，d1.b2 = 2 ，d1.b3 = 42，d1.d = 4
derived d2{ {}, {}, 4 };     // d2.b1 = 0，d2.b2 = 42，d2.b3 = 42，d2.d = 4


int main() {
	int n[10]{ n[0] = 1 };	//C语言的写法

}
/* 从初始化列表初始化聚合。它是列表初始化的一种形式。 (C++11 起) */

/*
聚合类使用 用户可以直接访问其成员，并具有特殊的初始化语法形式，需要满足如下:
	所有成员都是public
	没有定义构造函数
	没有类内初始值
	没有基类，也没有虚函数
*/